<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Texture Orientation Test</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
            max-width: 400px;
        }
        button {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background: #1976D2;
        }
        #debug {
            margin-top: 10px;
            font-size: 12px;
            font-family: monospace;
        }
        .marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background: red;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Texture Orientation Test</h3>
        <p>Testing where 0°,0° (Equator/Prime Meridian) appears on the PALEOMAP textures</p>
        <button onclick="testLocation(0, 0, 'Equator/Prime Meridian')">0°, 0°</button>
        <button onclick="testLocation(51.5074, -0.1278, 'London')">London</button>
        <button onclick="testLocation(-33.8688, 151.2093, 'Sydney')">Sydney (-33.9°, 151.2°)</button>
        <button onclick="toggleWireframe()">Toggle Wireframe</button>
        <button onclick="rotateToLocation()">Rotate to Pin</button>
        <div id="debug">Click a location to test</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let earth, pin;
        let wireframe = false;
        let currentLocation = null;
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000033);
            
            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 3);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x808080);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Load texture and create Earth
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'textures/paleomap/timeline/Map1a PALEOMAP PaleoAtlas_000.jpg',
                (texture) => {
                    createEarth(texture);
                    document.getElementById('debug').innerHTML += '<br>Texture loaded successfully';
                },
                undefined,
                (error) => {
                    console.error('Failed to load texture:', error);
                    // Create Earth without texture
                    createEarth(null);
                    document.getElementById('debug').innerHTML += '<br>Failed to load texture - using blue sphere';
                }
            );
            
            // Create pin
            createPin();
            
            // Add axis helper
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);
            
            // Add grid lines on sphere
            addGridLines();
            
            // Mouse controls
            setupControls();
            
            // Start animation
            animate();
        }
        
        function createEarth(texture) {
            const geometry = new THREE.SphereGeometry(1, 64, 32);
            const material = texture ? 
                new THREE.MeshPhongMaterial({ map: texture }) : 
                new THREE.MeshPhongMaterial({ color: 0x2194ce });
            
            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);
        }
        
        function createPin() {
            pin = new THREE.Group();
            
            // Red sphere at surface
            const sphereGeometry = new THREE.SphereGeometry(0.03, 16, 16);
            const redMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const sphere = new THREE.Mesh(sphereGeometry, redMaterial);
            pin.add(sphere);
            
            // Vertical shaft
            const shaftGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.2, 8);
            const shaft = new THREE.Mesh(shaftGeometry, redMaterial);
            shaft.position.y = 0.1;
            pin.add(shaft);
            
            // Pin head
            const headGeometry = new THREE.SphereGeometry(0.02, 16, 16);
            const head = new THREE.Mesh(headGeometry, redMaterial);
            head.position.y = 0.2;
            pin.add(head);
            
            scene.add(pin);
        }
        
        function addGridLines() {
            // Add meridian and equator lines
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffff00, 
                transparent: true, 
                opacity: 0.5 
            });
            
            // Equator
            const equatorPoints = [];
            for (let i = 0; i <= 360; i += 5) {
                const rad = (i * Math.PI) / 180;
                equatorPoints.push(new THREE.Vector3(
                    Math.cos(rad) * 1.01,
                    0,
                    Math.sin(rad) * 1.01
                ));
            }
            const equatorGeometry = new THREE.BufferGeometry().setFromPoints(equatorPoints);
            const equator = new THREE.Line(equatorGeometry, lineMaterial);
            scene.add(equator);
            
            // Prime Meridian (0° longitude)
            const meridianPoints = [];
            for (let lat = -90; lat <= 90; lat += 5) {
                const latRad = (lat * Math.PI) / 180;
                meridianPoints.push(new THREE.Vector3(
                    0,
                    Math.sin(latRad) * 1.01,
                    Math.cos(latRad) * 1.01
                ));
            }
            const meridianGeometry = new THREE.BufferGeometry().setFromPoints(meridianPoints);
            const meridian = new THREE.Line(meridianGeometry, lineMaterial);
            scene.add(meridian);
        }
        
        function testLocation(lat, lng, name) {
            currentLocation = { lat, lng, name };
            
            const radius = 1.05; // Slightly above surface
            
            // Convert to radians
            const latRad = (lat * Math.PI) / 180;
            const lngRad = (lng * Math.PI) / 180;
            
            // Standard spherical to Cartesian conversion
            // Note: In our coordinate system:
            // - Y is up (north)
            // - Z is forward (0° longitude when rotation.y = 0)
            // - X is right (90° East when rotation.y = 0)
            const x = radius * Math.cos(latRad) * Math.sin(lngRad);
            const y = radius * Math.sin(latRad);
            const z = radius * Math.cos(latRad) * Math.cos(lngRad);
            
            // Position pin
            pin.position.set(x, y, z);
            
            // Orient pin to point outward
            pin.up.set(0, 1, 0);
            pin.lookAt(x * 2, y * 2, z * 2);
            
            // Update debug info
            document.getElementById('debug').innerHTML = `
                <strong>${name}</strong><br>
                Lat: ${lat}°, Lng: ${lng}°<br>
                Cartesian: x=${x.toFixed(3)}, y=${y.toFixed(3)}, z=${z.toFixed(3)}<br>
                <br>
                Expected location:<br>
                - Sydney should be in eastern Australia<br>
                - London should be in western Europe<br>
                - 0,0 should be off west Africa (Gulf of Guinea)
            `;
        }
        
        function toggleWireframe() {
            wireframe = !wireframe;
            if (earth && earth.material) {
                earth.material.wireframe = wireframe;
            }
        }
        
        function rotateToLocation() {
            if (!currentLocation) return;
            
            // Rotate Earth to center on current pin location
            const lngRad = (currentLocation.lng * Math.PI) / 180;
            earth.rotation.y = -lngRad;
        }
        
        function setupControls() {
            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!mouseDown || !earth) return;
                
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                earth.rotation.y += deltaX * 0.01;
                earth.rotation.x += deltaY * 0.01;
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            // Zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.002;
                camera.position.z = Math.max(1.5, Math.min(5, camera.position.z));
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update pin position to stay fixed on globe
            if (pin && currentLocation && earth) {
                const lat = currentLocation.lat;
                const lng = currentLocation.lng;
                const radius = 1.05;
                
                const latRad = (lat * Math.PI) / 180;
                const lngRad = (lng * Math.PI) / 180;
                
                // Include Earth's rotation
                const rotatedLng = lngRad + earth.rotation.y;
                
                const x = radius * Math.cos(latRad) * Math.sin(rotatedLng);
                const y = radius * Math.sin(latRad);
                const z = radius * Math.cos(latRad) * Math.cos(rotatedLng);
                
                pin.position.set(x, y, z);
                pin.lookAt(x * 2, y * 2, z * 2);
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Initialize
        init();
        
        // Test Sydney by default after a short delay
        setTimeout(() => {
            testLocation(-33.8688, 151.2093, 'Sydney');
        }, 1000);
    </script>
</body>
</html>